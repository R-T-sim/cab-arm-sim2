<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CAB 2D – mm座標 / 剛体チェーン / 静置スタート / インパルス接触 / dt=1/600</title>
<style>
:root{--bg:#0b1020;--fg:#e8eef9;--muted:#9fb3d9;--card:#121a33;--good:#26d07c;--arm:#ff5a5a}
html,body{height:100%} body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:370px 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
.card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.panel{padding:14px 14px 10px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px}h2{font-size:13px;margin:8px 0 2px;color:var(--muted);font-weight:600}
.row{display:flex;align-items:center;gap:10px}.row label{min-width:155px;font-size:12px;color:var(--muted)}
input[type=range]{width:100%}.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:12px;padding:9px 12px;cursor:pointer;font-weight:600}
.btn.secondary{background:#19254a;color:var(--fg);border:1px solid #2a3a6a}
.kbd{display:inline-block;padding:2px 8px;border-radius:8px;background:#10172a;border:1px solid #1d2744;font-size:12px;color:var(--muted)}
.legend{font-size:12px;color:var(--muted)} canvas{width:100%;height:100%;display:block}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>ホイスト（緑：操作）＋ 吊具フレーム＆アーム（赤：受動）＋ CAB（青）</h1>
      <div class="legend">原点=フック(0,0)、X右＋/Y上＋、単位=mm。重力は下向き 9.8 m/s²。台車は |v| ≤ 0.3 m/s。</div>
    </div>

    <h2>ホイスト</h2>
    <div class="row"><label>指令加速度 a_cmd [mm/s²]</label><input id="acmd" type="range" min="100" max="4000" step="50" value="1500"><span id="acmdv">1500</span></div>
    <div class="row"><label>速度上限 |vᵗ|max [mm/s]</label><input id="vmax" type="range" min="50" max="600" step="10" value="300"><span id="vmaxv">300</span></div>
    <div class="row"><label>台車粘性 cᵗ [1/s]</label><input id="cd" type="range" min="0" max="2" step="0.02" value="0.25"><span id="cdv">0.25</span></div>

    <div class="row" style="gap:12px;margin-top:6px;flex-wrap:wrap">
      <button class="btn" id="reset">リセット</button>
      <button class="btn secondary" id="pause">一時停止</button>
    </div>

    <h2>吊具フレーム（剛体チェーンで懸垂）</h2>
    <div class="row"><label>フレーム質量 m_f [kg]</label><input id="mf" type="range" min="10" max="500" step="5" value="120"><span id="mfv">120</span></div>
    <div class="row"><label>チェーン長 Lc [mm]</label><input id="Lc" type="range" min="50" max="500" step="5" value="100"><span id="Lcv">100</span></div>
    <div class="row"><label>フレーム粘性 c_f [1/s]</label><input id="cf" type="range" min="0" max="2" step="0.02" value="0.10"><span id="cfv">0.10</span></div>

    <h2>アーム（自由回転＋外側90°ストッパ）</h2>
    <div class="row"><label>アーム長 L_arm [mm]</label><input id="Larm" type="range" min="600" max="2000" step="10" value="1300"><span id="Larmv">1300</span></div>
    <div class="row"><label>アーム質量 m_arm [kg]</label><input id="marm" type="range" min="5" max="200" step="1" value="30"><span id="marmv">30</span></div>
    <div class="row"><label>回転減衰 c_arm [N·m·s/rad]</label><input id="cdarm" type="range" min="0" max="50" step="0.5" value="8"><span id="cdarmv">8.0</span></div>

    <h2>接触（受面：インパルス法／摩擦のみ）</h2>
    <div class="row"><label>受け溝深さ d [mm]</label><input id="groove" type="range" min="10" max="200" step="5" value="80"><span id="groovev">80</span></div>
    <div class="row"><label>摩擦係数 μ</label><input id="mu" type="range" min="0" max="1" step="0.01" value="0.30"><span id="muv">0.30</span></div>

    <h2>CAB（青）</h2>
    <div class="row"><label>質量 m [kg]</label><input id="mass" type="range" min="50" max="2000" step="10" value="400"><span id="massv">400</span></div>
    <div class="row"><label>幅 W [mm]</label><input id="W" type="range" min="600" max="2800" step="10" value="1800"><span id="Wv">1800</span></div>
    <div class="row"><label>高さ H [mm]</label><input id="H" type="range" min="600" max="2400" step="10" value="1200"><span id="Hv">1200</span></div>
    <div class="row"><label>初期 重心X [mm]</label><input id="cx0" type="range" min="-2000" max="2000" step="1" value="7"><span id="cx0v">7</span></div>
    <div class="row"><label>（参考）初期 重心Y [mm]</label><input id="cy0" type="range" min="-3000" max="500" step="1" value="-1800" disabled><span id="cy0v">※初期は受面に自動スナップ</span></div>
    <div class="row"><label>回転減衰 cφ [N·m·s/rad]</label><input id="cdphi" type="range" min="0" max="200" step="1" value="10"><span id="cdphiv">10</span></div>

    <div class="legend" style="margin-top:8px">
      操作：<span class="kbd">←</span><span class="kbd">→</span> = 台車加減速（|v|≤0.3m/s）、<span class="kbd">Space</span> = ブレーキ、<span class="kbd">P</span> = 一時停止、<span class="kbd">R</span> = リセット
    </div>
    <pre id="readout" class="legend" style="background:#0e152e;padding:8px;border-radius:10px;white-space:pre-wrap"></pre>
  </div>

  <div class="card" style="position:relative;overflow:hidden"><canvas id="cv"></canvas></div>
</div>

<script>
(function(){
  // ===== Canvas =====
  const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
  const DPR=Math.max(1,window.devicePixelRatio||1);
  function resize(){const r=cv.getBoundingClientRect();const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR));if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;}}
  window.addEventListener('resize',resize); resize();
  function ppm(){const W=cv.width,H=cv.height;return Math.max(Math.min(W/6000,H/4000),0.08)}

  // ===== UI =====
  function bind(id, lab, setter, fmt){const s=document.getElementById(id),l=document.getElementById(lab);const apply=()=>{const v=parseFloat(s.value);setter(v);l.textContent=fmt?fmt(v):String(v)};s.addEventListener('input',apply);apply();return{s,l};}
  let a_cmd=1500,vmax=300,ccart=0.25;
  let mF=120,Lc=100,cF=0.10;
  let Larm=1300,mArm=30,cArm=8.0;
  let groove=80,mu=0.30;
  let m=400,Wmm=1800,Hmm=1200,cdphi=10,cx0=7;
  bind('acmd','acmdv',v=>a_cmd=v,v=>v.toFixed(0));
  bind('vmax','vmaxv',v=>vmax=v,v=>v.toFixed(0));
  bind('cd','cdv',v=>ccart=v,v=>v.toFixed(2));
  bind('mf','mfv',v=>mF=v,v=>v.toFixed(0));
  bind('Lc','Lcv',v=>Lc=v,v=>v.toFixed(0));
  bind('cf','cfv',v=>cF=v,v=>v.toFixed(2));
  bind('Larm','Larmv',v=>Larm=v,v=>v.toFixed(0));
  bind('marm','marmv',v=>mArm=v,v=>v.toFixed(0));
  bind('cdarm','cdarmv',v=>cArm=v,v=>v.toFixed(1));
  bind('groove','groovev',v=>groove=v,v=>v.toFixed(0));
  bind('mu','muv',v=>mu=v,v=>v.toFixed(2));
  bind('W','Wv',v=>Wmm=v,v=>v.toFixed(0));
  bind('H','Hv',v=>Hmm=v,v=>v.toFixed(0));
  bind('cx0','cx0v',v=>cx0=v,v=>v.toFixed(0));
  bind('cdphi','cdphiv',v=>cdphi=v,v=>v.toFixed(0));

  // ===== State =====
  let t=0,dt=1/600;
  // Hoist
  let xt=0,vt=0;
  // Chain-hung frame (pivot line y≈-100)
  let xF=0,yF=-100,vFx=0,vFy=0;
  // Arms (free rotation)
  let thL=1.5*Math.PI,wL=0; // 左: [π,1.5π]
  let thR=1.5*Math.PI,wR=0; // 右: [1.5π,2π]
  // CAB
  let cx=7,cy=-1800,cvx=0,cvy=0,phi=0,omega=0;

  const gmm=-9810, g=9.81;
  const rootOfsL={x:-700,y:0}, rootOfsR={x:700,y:0};

  // buttons & keys
  const btnReset=document.getElementById('reset'), btnPause=document.getElementById('pause'); let paused=false;
  btnReset.addEventListener('click',()=>reset());
  btnPause.addEventListener('click',()=>{paused=!paused;btnPause.textContent=paused?'再開':'一時停止';});
  let keyL=false,keyR=false,brake=false;
  window.addEventListener('keydown',e=>{if(e.code==='ArrowLeft')keyL=true;if(e.code==='ArrowRight')keyR=true;if(e.code==='Space')brake=true;if(e.key==='r'||e.key==='R')reset();if(e.key==='p'||e.key==='P'){paused=!paused;btnPause.textContent=paused?'再開':'一時停止';}});
  window.addEventListener('keyup',e=>{if(e.code==='ArrowLeft')keyL=false;if(e.code==='ArrowRight')keyR=false;if(e.code==='Space')brake=false;});

  function reset(){
    t=0; xt=0; vt=0;
    xF=0; yF=-100; vFx=0; vFy=0;
    thL=1.5*Math.PI; thR=1.5*Math.PI; wL=0; wR=0;
    cx=cx0; phi=0; omega=0; cvx=0; cvy=0;

    // --- 初期は受面に“静置”して上下動をゼロに ---
    // アーム先端高さ（下向き開始）
    const rootLW={x:xF+rootOfsL.x,y:yF+rootOfsL.y};
    const aY = rootLW.y + Math.sin(thL)*Larm; // 左右同じ値
    const yG = Hmm/2 - groove;               // CABローカル溝高さ
    cy = aY - yG;                            // pC.y = a.y
    // 縦速度も0
    cvy = 0;
    paused=false; btnPause.textContent='一時停止';
  }
  reset();

  // ===== Helpers =====
  // 剛体チェーン拘束（|H-F|=Lc）：フレーム速度/位置を補正（張力のみ）
  function rigidChainConstraint(){
    const Hx=xt, Hy=0, vxH=vt, vyH=0;
    let rx=xF-Hx, ry=yF-Hy; let len=Math.hypot(rx,ry);
    if(len<1e-6){ rx=0; ry=-Lc; len=Lc; }
    let nx=rx/len, ny=ry/len;

    // 位置誤差を戻す（Baumgarte）
    const err = len - Lc;  // >0 伸び、<0 たるみ
    // たるみ時は何もしない（チェーンは押せない）
    if(err<0){
      // ただし重力で必ず張るので、そのまま自由落下
      return;
    }
    // 位置をピッタリに
    xF = Hx + nx*Lc;
    yF = Hy + ny*Lc;

    // 速度拘束： (vF - vH)·n = 0 になるようインパルス
    const vrel = (vFx - vxH)*nx + (vFy - vyH)*ny; // [mm/s]
    if(vrel>0){ // 離れる方向はOK（張力不要）
      return;
    }
    // 有効質量（ホイストは運動学扱い→フレームのみ）
    const J = - (vrel/1000) * mF; // [N·s] = kg * (m/s)
    // 張力のみ（J>=0）にクランプ
    const Jt = Math.max(0, J);
    vFx += (1000*Jt/mF)*nx;
    vFy += (1000*Jt/mF)*ny;
  }

  // 受面インパルス（法線のみ・摩擦あり）
  function supportImpulse(side, a, vA, pC, vC, rCW, th, Iarm){
    const tol=0.5; // mm
    // 少量の重なりは位置で戻す（震え防止）
    if(pC.y < a.y){ const dy=a.y - pC.y; cy += dy; pC.y += dy; }

    // CAB慣性
    const Icab = m*((Wmm/1000)**2 + (Hmm/1000)**2)/12;
    const rxm=rCW.x/1000, rym=rCW.y/1000;

    // 法線（上向き）インパルス
    const vrel_n = vC.y - vA.y; // (mm/s) 下向きなら負
    if(pC.y <= a.y + tol && vrel_n < 0){
      const kN = 1/m + (rxm*rxm)/Icab;
      const Pn = Math.max(0, - (vrel_n/1000)/kN); // N·s
      cvy   += (1000*Pn)/m;           // CAB
      omega += (rxm*Pn)/Icab;
      const rTipx=(Larm*Math.cos(th))/1000; // アーム反作用
      if(side==='L') wL += (-(rTipx*Pn))/Iarm; else wR += (-(rTipx*Pn))/Iarm;
      // 摩擦（クーロン）
      const kT = 1/m + (rym*rym)/Icab;
      const vrel_t = vC.x - vA.x;
      const Pt_unc = - (vrel_t/1000)/kT;
      const Pt = Math.max(-mu*Pn, Math.min(mu*Pn, Pt_unc));
      cvx   += (1000*Pt)/m;
      omega += (-(rym)*Pt)/Icab;
      const rTipy=(Larm*Math.sin(th))/1000;
      if(side==='L') wL += (rTipy*Pt)/Iarm; else wR += (rTipy*Pt)/Iarm;
    }
  }

  // ===== Step =====
  function step(){
    // Hoist
    let u=0;if(keyL)u-=a_cmd;if(keyR)u+=a_cmd;if(brake)u+=-3*vt;
    vt += (u - ccart*vt)*dt; if(vt>vmax)vt=vmax;if(vt<-vmax)vt=-vmax; xt += vt*dt;

    // Frame free + gravity
    vFx += (-cF*vFx)*dt;                     // 横粘性
    vFy += (gmm/1000 - cF*vFy)*dt;           // 重力＋縦粘性
    xF  += vFx*dt; yF += vFy*dt;

    // Rigid chain constraint
    rigidChainConstraint();

    // Geometry
    const rootLW={x:xF+rootOfsL.x, y:yF+rootOfsL.y};
    const rootRW={x:xF+rootOfsR.x, y:yF+rootOfsR.y};
    const aL={x:rootLW.x + Larm*Math.cos(thL), y:rootLW.y + Larm*Math.sin(thL)};
    const aR={x:rootRW.x + Larm*Math.cos(thR), y:rootRW.y + Larm*Math.sin(thR)};
    const vAL={x:vFx - wL*(Larm*Math.sin(thL)), y:vFy + wL*(Larm*Math.cos(thL))};
    const vAR={x:vFx - wR*(Larm*Math.sin(thR)), y:vFy + wR*(Larm*Math.cos(thR))};

    const cph=Math.cos(phi), sph=Math.sin(phi);
    const xL_loc=-Wmm/2+60, xR_loc=Wmm/2-60, yG=Hmm/2 - groove;
    const pCL={x:cx + cph*xL_loc - sph*yG, y:cy + sph*xL_loc + cph*yG};
    const pCR={x:cx + cph*xR_loc - sph*yG, y:cy + sph*xR_loc + cph*yG};
    const rLw={x:cph*xL_loc - sph*yG, y:sph*xL_loc + cph*yG};
    const rRw={x:cph*xR_loc - sph*yG, y:sph*xR_loc + cph*yG};
    const vCL={x:cvx - omega*rLw.y, y:cvy + omega*rLw.x};
    const vCR={x:cvx - omega*rRw.y, y:cvy + omega*rRw.x};

    // Contact impulses
    const Lm=Larm/1000, Iarm=mArm*Lm*Lm/3;
    supportImpulse('L',aL,vAL,pCL,vCL,rLw,thL,Iarm);
    supportImpulse('R',aR,vAR,pCR,vCR,rRw,thR,Iarm);

    // CAB gravity & damping
    cvy += gmm*dt/1000;
    cx  += cvx*dt; cy += cvy*dt;
    const Icab=m*((Wmm/1000)**2+(Hmm/1000)**2)/12;
    omega += (-cdphi*omega/Icab)*dt; phi += omega*dt;

    // Arm gravity + damping
    const tauLg = - mArm*g*(Lm/2)*Math.cos(thL);
    const tauRg = - mArm*g*(Lm/2)*Math.cos(thR);
    wL += ((tauLg - cArm*wL)/Iarm)*dt; thL += wL*dt;
    wR += ((tauRg - cArm*wR)/Iarm)*dt; thR += wR*dt;

    // Angle stoppers：左[π,1.5π]、右[1.5π,2π]
    const pi=Math.PI, hi=1.5*pi, tw=2*pi;
    if(thL>hi){thL=hi; if(wL>0) wL=0;}
    if(thL<pi){thL=pi; if(wL<0) wL=0;}
    if(thR<hi){thR=hi; if(wR<0) wR=0;}
    if(thR>tw){thR=tw; if(wR>0) wR=0;}

    return {rootLW,rootRW,aL,aR,pCL,pCR};
  }

  // ===== Draw =====
  const readout=document.getElementById('readout');
  function draw(cache){
    const s=ppm(); resize();
    const W=cv.width,H=cv.height; const ox=W*0.5, oy=H*0.15;
    const sx=x=>ox+x*s, sy=y=>oy-y*s;

    ctx.clearRect(0,0,W,H);

    // Grid
    ctx.save(); ctx.strokeStyle='#1b2445'; ctx.lineWidth=1;
    const g=200; for(let x=-8000;x<=8000;x+=g){ctx.beginPath();ctx.moveTo(sx(x),0);ctx.lineTo(sx(x),H);ctx.stroke();}
    for(let y=-4000;y<=4000;y+=g){ctx.beginPath();ctx.moveTo(0,sy(y));ctx.lineTo(W,sy(y));ctx.stroke();}
    ctx.restore();

    // Hoist
    ctx.fillStyle='#26d07c'; const w=220,h=120;
    ctx.fillRect(sx(xt)-w/2, sy(200)-h/2, w, h);
    ctx.strokeStyle='#26d07c'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(0)); ctx.lineTo(sx(xt),sy(200)); ctx.stroke();

    // Chain (rigid, visual)：Hoist→Frame center
    const midX=(cache.rootLW.x+cache.rootRW.x)/2;
    ctx.strokeStyle='#7bd6a8'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(0)); ctx.lineTo(sx(midX), sy(cache.rootLW.y)); ctx.stroke();

    // Frame beam
    ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(sx(cache.rootLW.x-300),sy(cache.rootLW.y)); ctx.lineTo(sx(cache.rootRW.x+300),sy(cache.rootRW.y)); ctx.stroke();

    // Arms
    ctx.beginPath(); ctx.moveTo(sx(cache.rootLW.x),sy(cache.rootLW.y)); ctx.lineTo(sx(cache.aL.x),sy(cache.aL.y)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx(cache.rootRW.x),sy(cache.rootRW.y)); ctx.lineTo(sx(cache.aR.x),sy(cache.aR.y)); ctx.stroke();
    ctx.fillStyle='#ffb3b3'; ctx.fillRect(sx(cache.aL.x)-6,sy(cache.aL.y)-3,12,6); ctx.fillRect(sx(cache.aR.x)-6,sy(cache.aR.y)-3,12,6);

    // CAB
    ctx.save(); ctx.translate(sx(cx),sy(cy)); ctx.rotate(-phi);
    ctx.fillStyle='rgba(127,182,255,0.9)'; ctx.fillRect(-Wmm*s/2, +Hmm*s/2 - Hmm*s, Wmm*s, Hmm*s);
    ctx.restore();

    // groove markers
    ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(sx(cache.pCL.x), sy(cache.pCL.y), 4, 0, 2*Math.PI); ctx.fill();
    ctx.beginPath(); ctx.arc(sx(cache.pCR.x), sy(cache.pCR.y), 4, 0, 2*Math.PI); ctx.fill();

    readout.textContent =
      `t=${t.toFixed(2)} s  |  v_t=${vt.toFixed(1)} mm/s (lim ${vmax.toFixed(0)})\n`+
      `Frame c=(${((cache.rootLW.x+cache.rootRW.x)/2).toFixed(1)}, ${cache.rootLW.y.toFixed(1)})  |  Arms θL=${(thL*180/Math.PI).toFixed(1)}° θR=${(thR*180/Math.PI).toFixed(1)}°\n`+
      `CAB c=(${cx.toFixed(1)}, ${cy.toFixed(1)})  φ=${(phi*180/Math.PI).toFixed(2)}°  μ=${mu.toFixed(2)}`;
  }

  // ===== Loop =====
  let last=performance.now(),acc=0,cache={rootLW:{x:xF+rootOfsL.x,y:yF},rootRW:{x:xF+rootOfsR.x,y:yF},aL:{x:0,y:0},aR:{x:0,y:0},pCL:{x:cx,y:cy},pCR:{x:cx,y:cy}};
  function loop(now){
    const el=(now-last)/1000; last=now; resize();
    if(!paused){acc+=Math.min(el,0.1); while(acc>=dt){ cache=step(); t+=dt; acc-=dt; }}
    draw(cache); requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
