<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CAB 2D v4（剛体チェーン/慣性遅れ修正+初期姿勢/描画修正）</title>
<style>
:root{--bg:#0b1020;--fg:#e8eef9;--muted:#9fb3d9;--card:#121a33;--good:#26d07c;--arm:#ff5a5a;--cab:#7fb6ff}
html,body{height:100%}body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
.card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.panel{padding:14px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px}h2{font-size:13px;margin:8px 0 2px;color:var(--muted);font-weight:600}
.row{display:flex;align-items:center;gap:10px}.row label{min-width:170px;font-size:12px;color:var(--muted)}
input[type=range]{width:100%}.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:12px;padding:9px 12px;cursor:pointer;font-weight:600}
.btn.secondary{background:#19254a;color:var(--fg);border:1px solid #2a3a6a}
.kbd{display:inline-block;padding:2px 8px;border-radius:8px;background:#10172a;border:1px solid #1d2744;font-size:12px;color:var(--muted)}
.legend{font-size:12px;color:var(--muted)}canvas{width:100%;height:100%;display:block}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>ホイスト（緑：操作）＋ 吊具フレーム＆アーム（赤）＋ CAB（青）</h1>
      <div class="legend">
        原点=フック(0,0)、X右＋/Y上＋、単位=mm。重力は下向き 9.8 m/s²。台車は |v| ≤ 0.3 m/s。<br>
        v4：<b>チェーンは剛体長（伸び無し）を位置＆速度で厳密拘束</b>。<b>フレーム粘性は無視</b>。
      </div>
    </div>

    <h2>ホイスト</h2>
    <div class="row"><label>指令加速度 a<sub>cmd</sub> [mm/s²]</label><input id="acmd" type="range" min="100" max="6000" step="50" value="3000"><span id="acmdv">3000</span></div>
    <div class="row"><label>速度上限 |vᵗ|max [mm/s]</label><input id="vmax" type="range" min="50" max="600" step="10" value="300"><span id="vmaxv">300</span></div>
    <div class="row"><label>台車粘性 cᵗ [1/s]</label><input id="cd" type="range" min="0" max="2" step="0.02" value="0.26"><span id="cdv">0.26</span></div>

    <div class="row" style="gap:12px;margin-top:6px;flex-wrap:wrap">
      <button class="btn" id="reset">リセット</button>
      <button class="btn secondary" id="pause">一時停止</button>
    </div>

    <h2>フレーム/チェーン</h2>
    <div class="row"><label>フレーム質量 m<sub>F</sub> [kg]</label><input id="mf" type="range" min="10" max="800" step="10" value="150"><span id="mfv">150</span></div>
    <div class="row"><label>チェーン長 L<sub>c</sub> [mm]</label><input id="Lc" type="range" min="50" max="2000" step="1" value="150"><span id="Lcv">150</span></div>

    <h2>アーム（落とし→ひざ→縦棒→棚＋返し）</h2>
    <div class="row"><label>落とし L<sub>drop</sub> [mm]</label><input id="ldrop" type="range" min="40" max="800" step="5" value="220"><span id="ldropv">220</span></div>
    <div class="row"><label>ひざ 外 L<sub>knee</sub> [mm]</label><input id="lknee" type="range" min="40" max="600" step="5" value="140"><span id="lkneev">140</span></div>
    <div class="row"><label>ひざ 下 D<sub>knee</sub> [mm]</label><input id="dknee" type="range" min="40" max="600" step="5" value="160"><span id="dkneev">160</span></div>
    <div class="row"><label>縦棒 L<sub>vert</sub> [mm]</label><input id="lvert" type="range" min="200" max="3000" step="10" value="1200"><span id="lvertv">1200</span></div>
    <div class="row"><label>棚長 L<sub>s</sub> [mm]</label><input id="slen" type="range" min="40" max="800" step="5" value="160"><span id="slenv">160</span></div>
    <div class="row"><label>返し高さ H<sub>lip</sub> [mm]</label><input id="hlip" type="range" min="10" max="200" step="2" value="80"><span id="hlipv">80</span></div>

    <h2>CAB</h2>
    <div class="row"><label>質量 m [kg]</label><input id="mass" type="range" min="50" max="3000" step="10" value="400"><span id="massv">400</span></div>
    <div class="row"><label>幅 W [mm]</label><input id="W" type="range" min="400" max="4000" step="10" value="1800"><span id="Wv">1800</span></div>
    <div class="row"><label>高さ H [mm]</label><input id="H" type="range" min="400" max="4000" step="10" value="1200"><span id="Hv">1200</span></div>
    <div class="row"><label>初期 COM X [mm]</label><input id="cx0" type="range" min="-4000" max="4000" step="1" value="7"><span id="cx0v">7</span></div>
    <div class="row"><label>摩擦係数 μ</label><input id="mu" type="range" min="0" max="1" step="0.01" value="0.30"><span id="muv">0.30</span></div>
    <div class="row"><label>回転減衰 cφ [N·m·s/rad]</label><input id="cdphi" type="range" min="0" max="200" step="1" value="10"><span id="cdphiv">10</span></div>

    <div class="legend" style="margin-top:8px">
      操作：<span class="kbd">←</span><span class="kbd">→</span> = 台車加減速（|v|≤0.3m/s）、<span class="kbd">Space</span> = ブレーキ、<span class="kbd">P</span> = 一時停止、<span class="kbd">R</span> = リセット
    </div>
    <pre id="readout" class="legend" style="background:#0e152e;padding:8px;border-radius:10px;white-space:pre-wrap"></pre>
  </div>

  <div class="card" style="position:relative;overflow:hidden"><canvas id="cv"></canvas></div>
</div>

<script>
(function(){
  // ===== Canvas =====
  const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
  const DPR=Math.max(1,window.devicePixelRatio||1);
  function resize(){const r=cv.getBoundingClientRect();const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;}}
  window.addEventListener('resize',resize); resize();
  function PPM(){const W=cv.width,H=cv.height;return Math.max(Math.min(W/6000,H/4200),0.08);}

  // ===== Bind UI =====
  function bind(id, lab, setter, fmt){const s=document.getElementById(id),l=document.getElementById(lab);const apply=()=>{const v=parseFloat(s.value);setter(v);l.textContent=fmt?fmt(v):String(v)};s.addEventListener('input',apply);apply();}
  let a_cmd=3000, vmax=300, ccart=0.26;
  let mF=150, Lc=150;
  let frameSpan=2400, frameH=120;
  let anchor_local={x:0, y:80};
  let rootL_local={x:-700, y:-100}, rootR_local={x:700, y:-100};
  let L_drop=220, L_knee=140, D_knee=160, L_vert=1200, Ls=160, H_lip=80;
  let m=400, Wmm=1800, Hmm=1200, mu=0.30, cdphi=10, cx0=7;
  bind('acmd','acmdv',v=>a_cmd=v,v=>v.toFixed(0));
  bind('vmax','vmaxv',v=>vmax=v,v=>v.toFixed(0));
  bind('cd','cdv',v=>ccart=v,v=>v.toFixed(2));
  bind('mf','mfv',v=>mF=v,v=>v.toFixed(0));
  bind('Lc','Lcv',v=>Lc=v,v=>v.toFixed(0));
  bind('ldrop','ldropv',v=>L_drop=v,v=>v.toFixed(0));
  bind('lknee','lkneev',v=>L_knee=v,v=>v.toFixed(0));
  bind('dknee','dkneev',v=>D_knee=v,v=>v.toFixed(0));
  bind('lvert','lvertv',v=>L_vert=v,v=>v.toFixed(0));
  bind('slen','slenv',v=>Ls=v,v=>v.toFixed(0));
  bind('hlip','hlipv',v=>H_lip=v,v=>v.toFixed(0));
  bind('mass','massv',v=>m=v,v=>v.toFixed(0));
  bind('W','Wv',v=>Wmm=v,v=>v.toFixed(0));
  bind('H','Hv',v=>Hmm=v,v=>v.toFixed(0));
  bind('cx0','cx0v',v=>cx0=v,v=>v.toFixed(0));
  bind('mu','muv',v=>mu=v,v=>v.toFixed(2));
  bind('cdphi','cdphiv',v=>cdphi=v,v=>v.toFixed(0));

  // ===== State =====
  let t=0, dt=1/600;

  // サブステップと拘束反復（★追加）
  const SUB_STEPS = 8;     // 1/600 s を 8 分割
  const POS_ITERS  = 6;    // チェーン位置拘束の反復回数
  const EPS = 1e-9;

  // hoist
  let xt=0, vt=0;
  // frame (rigid)
  let xF=0, yF=-100, vFx=0, vFy=0, psi=0, wF=0;
  // cab
  let cx=cx0, cy=-1800, cvx=0, cvy=0, phi=0, omega=0;

  // ===== Math utils =====
  const gmm=-9810, g=9.81;
  function rot(a,v){const c=Math.cos(a),s=Math.sin(a);return {x:c*v.x - s*v.y, y:s*v.x + c*v.y};}
  function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
  function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
  function mul(v,k){return {x:v.x*k,y:v.y*k};}
  function len(v){return Math.hypot(v.x,v.y);}
  function posF(local){return add({x:xF,y:yF}, rot(psi, local));}
  function velAt(local){const r=rot(psi,local); return {x:vFx - wF*r.y, y:vFy + wF*r.x};}
  function I_frame(){const W=frameSpan/1000,H=frameH/1000; return mF*(W*W+H*H)/12;}
  function I_cab(){const W=Wmm/1000,H=Hmm/1000; return m*(W*W+H*H)/12;}

  // ===== Chain constraint (rigid length) =====
  // 位置レベル：|A-H| = Lc を厳密化（フレームのみ補正）
  function solveChainPosition(iter = POS_ITERS){
    for(let k=0;k<iter;k++){
      const H={x:xt,y:0}, A=posF(anchor_local);
      const r=sub(A,H); const L=len(r); if(L<EPS) return;
      const n=mul(r,1/L);              // H→A
      const C=L - Lc;                  // 長さ誤差
      if (Math.abs(C) < 1e-9) return;
      const rA=rot(psi,anchor_local);  // COM→アンカー
      const s = rA.x*n.y - rA.y*n.x;   // 回転寄与
      const w = 1/mF, wr = 1/Math.max(1e-9, I_frame());
      const denom = w + s*s*wr;
      const dl = C/denom;
      // フレーム並進・回転を同時に補正（ホイストは運動学）
      xF  -= w  * n.x * dl;
      yF  -= w  * n.y * dl;
      psi -= wr * s   * dl;
    }
  }

  // 速度レベル：チェーン方向の相対速度 = 0（張力のみ）
  function solveChainVelocity(){
    const H={x:xt,y:0}, vH={x:vt,y:0};
    const A=posF(anchor_local), vA=velAt(anchor_local);
    const r=sub(A,H); const L=len(r); if(L<EPS) return;
    const n=mul(r,1/L);
    const rAm=rot(psi,anchor_local); const rAm_m={x:rAm.x/1000,y:rAm.y/1000};
    const vrel = ((vA.x - vH.x)*n.x + (vA.y - vH.y)*n.y)/1000;           // m/s
    const K = 1/mF + ((rAm_m.x*n.y - rAm_m.y*n.x)**2)/I_frame();         // 有効質量
    let J = - vrel / K; if (J<0) J=0;                                    // N·s（張力のみ）
    vFx += (-n.x*1000*J)/mF; vFy += (-n.y*1000*J)/mF;
    wF  += ( (rAm_m.x*(-J*n.y) - rAm_m.y*(-J*n.x)) )/I_frame();
  }

  // ===== Step / Reset =====
  const btnReset=document.getElementById('reset'), btnPause=document.getElementById('pause'); let paused=false;
  btnReset.onclick=()=>reset();
  btnPause.onclick=()=>{paused=!paused;btnPause.textContent=paused?'再開':'一時停止';};
  let keyL=false,keyR=false,brake=false;
  addEventListener('keydown',e=>{if(e.code==='ArrowLeft')keyL=true;if(e.code==='ArrowRight')keyR=true;if(e.code==='Space')brake=true;if(e.key==='r'||e.key==='R')reset();if(e.key==='p'||e.key==='P'){paused=!paused;btnPause.textContent=paused?'再開':'一時停止';}});
  addEventListener('keyup',e=>{if(e.code==='ArrowLeft')keyL=false;if(e.code==='ArrowRight')keyR=false;if(e.code==='Space')brake=false;});

  // ★初期姿勢を図通りにセット（水平フレーム・チェーン垂直・アーム下向き・CAB静置）
  function reset(){
    t=0;
    // Hoist
    xt=0; vt=0;
    // Frame：ψ=0 で |A-H|=Lc を厳密に満たす xF,yF
    // A=(xF+Ax, yF+Ay), H=(xt,0) → xF=xt-Ax, yF=-Ay-Lc
    xF = xt - anchor_local.x;
    yF = -anchor_local.y - Lc;
    vFx=0; vFy=0; psi=0; wF=0;

    // CAB：左棚外端の高さに溝を合わせる（phi=0）
    // rootL_world = (xF,yF)+rootL_local
    const rootLW = add({x:xF,y:yF}, rootL_local);
    const dDown = {x:0, y:-1}; // ψ=0 なのでそのまま下向き
    const Lsum  = L_drop + D_knee + L_vert;
    const shelfOuterL = add(rootLW, mul(dDown, Lsum));
    const yG = Hmm/2 - 80; // 溝深さの既定値に合わせる（必要に応じて値を同期）
    phi=0; omega=0; cvx=0; cvy=0; cx=cx0; cy = shelfOuterL.y - yG;

    paused=false; btnPause.textContent='一時停止';
  }

  function step(){
    const h = dt / SUB_STEPS;
    for(let s=0;s<SUB_STEPS;s++){
      // 1) Hoist（運動学）
      let u=0; if(keyL)u-=a_cmd; if(keyR)u+=a_cmd; if(brake)u+=-3*vt;
      vt += (u - ccart*vt)*h;
      if(vt>vmax)vt=vmax; if(vt<-vmax)vt=-vmax;
      xt += vt*h;

      // 2) 重力（フレーム粘性は無視）
      vFy += (gmm/1000)*h;

      // 3) チェーン拘束：位置 → 速度
      solveChainPosition(POS_ITERS);
      solveChainVelocity();

      // 4) フレーム積分
      xF += vFx*h; yF += vFy*h; psi += wF*h;

      // 5) CAB 重力
      cvy += gmm*h/1000;

      // 6) （簡略）棚面接触：棚外端の世界座標を再計算し、水平棚として扱う
      const rootLW = add({x:xF,y:yF}, rot(psi, rootL_local));
      const dDown = rot(psi, {x:0,y:-1});
      const Lsum  = L_drop + D_knee + L_vert;
      const S0L   = add(rootLW, mul(dDown, Lsum)); // 左棚外端（世界）
      const shelfY = S0L.y;                        // 水平棚と近似
      const shelfX0 = xF - 600, shelfX1 = xF + 600;

      const cph=Math.cos(phi), sph=Math.sin(phi);
      const yG = Hmm/2 - 80; // 溝深さ既定
      const xL_loc=-Wmm/2 + 60, xR_loc=Wmm/2 - 60;
      const pCL={x:cx + cph*xL_loc - sph*yG, y:cy + sph*xL_loc + cph*yG};
      const pCR={x:cx + cph*xR_loc - sph*yG, y:cy + sph*xR_loc + cph*yG};

      const n={x:0,y:1}, tdir={x:1,y:0};
      function contact(P){
        if(P.x<shelfX0 || P.x>shelfX1) return;
        const pen = (shelfY - P.y);
        const vP={x:cvx - omega*(P.y-cy), y:cvy + omega*(P.x-cx)};
        if(pen>0 && vP.y<0){
          const Icab=I_cab();
          const r={x:(P.x-cx)/1000, y:(P.y-cy)/1000};
          const K = 1/m + ((r.x*n.y - r.y*n.x)**2)/Icab;
          const vrelN = (vP.x*n.x + vP.y*n.y)/1000;
          const Jn = Math.max(0, -vrelN/K);
          cvx += (1000*Jn*n.x)/m; cvy += (1000*Jn*n.y)/m; omega += ( (r.x*Jn*n.y - r.y*Jn*n.x) )/Icab;
          const vrelT = (vP.x*tdir.x + vP.y*tdir.y)/1000;
          const Kt=1/m + ((r.x*tdir.y - r.y*tdir.x)**2)/Icab;
          const Jt_unc = - vrelT/Kt; const Jt = Math.max(-mu*Jn, Math.min(mu*Jn, Jt_unc));
          cvx += (1000*Jt*tdir.x)/m; cvy += (1000*Jt*tdir.y)/m; omega += ( (r.x*Jt*tdir.y - r.y*Jt*tdir.x))/Icab;
        }
      }
      contact(pCL); contact(pCR);

      // 7) CAB 積分
      cx += cvx*h; cy += cvy*h;
      const Icab=I_cab(); omega += (-cdphi*omega/Icab)*h; phi += omega*h;
    }
  }

  // ===== Draw =====
  const readout=document.getElementById('readout');
  function draw(){
    const s=PPM(); resize(); const W=cv.width,H=cv.height; const ox=W*0.5, oy=H*0.15; const sx=x=>ox+x*s, sy=y=>oy-y*s;
    ctx.clearRect(0,0,W,H);
    // grid
    ctx.save(); ctx.strokeStyle='#1b2445'; ctx.lineWidth=1; for(let x=-8000;x<=8000;x+=200){ctx.beginPath();ctx.moveTo(sx(x),0);ctx.lineTo(sx(x),H);ctx.stroke();}
    for(let y=-4000;y<=4000;y+=200){ctx.beginPath();ctx.moveTo(0,sy(y));ctx.lineTo(W,sy(y));ctx.stroke();} ctx.restore();
    // hoist & chain
    ctx.fillStyle='#26d07c'; ctx.fillRect(sx(xt)-110, sy(200)-60, 220, 120);
    ctx.strokeStyle='#26d07c'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(0)); ctx.lineTo(sx(xt),sy(200)); ctx.stroke();
    const anchor=posF(anchor_local); ctx.strokeStyle='#7bd6a8'; ctx.beginPath(); ctx.moveTo(sx(xt),sy(0)); ctx.lineTo(sx(anchor.x), sy(anchor.y)); ctx.stroke();
    // frame beam
    ctx.save(); ctx.translate(sx(xF), sy(yF)); ctx.rotate(-psi); ctx.fillStyle='#ff7070'; ctx.fillRect(-frameSpan*s/2, -frameH*s/2, frameSpan*s, frameH*s); ctx.restore();

    // アーム（★下向きで描画に修正）
    ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6;
    function drawArm(rootX, side){
      const rootW = add({x:xF,y:yF}, rot(psi,{x:rootX - xF, y:rootL_local.y}));
      const down = rot(psi,{x:0,y:-1});            // 下向き
      const fwd  = rot(psi,{x:1,y:0});             // フレーム+X
      const out  = (side==='L') ? mul(fwd,-1) : fwd;   // 外向き
      const inw  = mul(out,-1);                    // 内向き（棚方向）
      const P1 = rootW;
      const P2 = add(P1, mul(down, L_drop));
      const P3 = add(P2, add(mul(out, L_knee), mul(down, D_knee)));
      const P4 = add(P3, mul(down, L_vert));
      const P5 = add(P4, mul(inw, Ls));
      const P6 = add(P5, mul(mul(down,-1), H_lip)); // 返し（上向き）
      ctx.beginPath(); ctx.moveTo(sx(P1.x),sy(P1.y)); [P2,P3,P4,P5,P6].forEach(p=>{ctx.lineTo(sx(p.x),sy(p.y));}); ctx.stroke();
      ctx.strokeStyle='#ff9a9a'; ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(sx(P4.x),sy(P4.y)); ctx.lineTo(sx(P5.x),sy(P5.y)); ctx.stroke();
      ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6;
    }
    drawArm(xF+rootL_local.x,'L'); drawArm(xF+rootR_local.x,'R');

    // CAB
    ctx.save(); ctx.translate(sx(cx), sy(cy)); ctx.rotate(-phi);
    ctx.fillStyle='rgba(127,182,255,0.9)'; ctx.fillRect(-Wmm*s/2, +Hmm*s/2 - Hmm*s, Wmm*s, Hmm*s); ctx.restore();

    readout.textContent =
      `t=${t.toFixed(2)} s\n`+
      `Hoist x=${xt.toFixed(1)} mm, v=${vt.toFixed(1)} mm/s (≤${vmax.toFixed(0)})\n`+
      `Frame c=(${xF.toFixed(1)}, ${yF.toFixed(1)}) ψ=${(psi*180/Math.PI).toFixed(2)}°\n`+
      `CAB c=(${cx.toFixed(1)}, ${cy.toFixed(1)}) φ=${(phi*180/Math.PI).toFixed(2)}°`;
  }

  // loop
  let last=performance.now(), acc=0;
  function loop(now){
    const el=(now-last)/1000; last=now;
    if(!paused){ acc+=Math.min(el,0.12); while(acc>=dt){ step(); t+=dt; acc-=dt; } }
    draw(); requestAnimationFrame(loop);
  }
  reset(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
