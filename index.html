<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CAB 2D v4（剛体チェーン/慣性遅れ修正）</title>
<style>
:root{--bg:#0b1020;--fg:#e8eef9;--muted:#9fb3d9;--card:#121a33;--good:#26d07c;--arm:#ff5a5a;--cab:#7fb6ff}
html,body{height:100%}body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
.card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.panel{padding:14px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px}h2{font-size:13px;margin:8px 0 2px;color:var(--muted);font-weight:600}
.row{display:flex;align-items:center;gap:10px}.row label{min-width:170px;font-size:12px;color:var(--muted)}
input[type=range]{width:100%}.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:12px;padding:9px 12px;cursor:pointer;font-weight:600}
.btn.secondary{background:#19254a;color:var(--fg);border:1px solid #2a3a6a}
.kbd{display:inline-block;padding:2px 8px;border-radius:8px;background:#10172a;border:1px solid #1d2744;font-size:12px;color:var(--muted)}
.legend{font-size:12px;color:var(--muted)}canvas{width:100%;height:100%;display:block}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>ホイスト（緑：操作）＋ 吊具フレーム＆アーム（赤）＋ CAB（青）</h1>
      <div class="legend">
        原点=フック(0,0)、X右＋/Y上＋、単位=mm。重力は下向き 9.8 m/s²。台車は |v| ≤ 0.3 m/s。<br>
        v4：<b>チェーンは剛体長（伸び無し）を位置＆速度で厳密拘束</b>。<b>フレーム粘性は無視</b>。
      </div>
    </div>

    <h2>ホイスト</h2>
    <div class="row"><label>指令加速度 a<sub>cmd</sub> [mm/s²]</label><input id="acmd" type="range" min="100" max="6000" step="50" value="3000"><span id="acmdv">3000</span></div>
    <div class="row"><label>速度上限 |vᵗ|max [mm/s]</label><input id="vmax" type="range" min="50" max="600" step="10" value="300"><span id="vmaxv">300</span></div>
    <div class="row"><label>台車粘性 cᵗ [1/s]</label><input id="cd" type="range" min="0" max="2" step="0.02" value="0.26"><span id="cdv">0.26</span></div>

    <div class="row" style="gap:12px;margin-top:6px;flex-wrap:wrap">
      <button class="btn" id="reset">リセット</button>
      <button class="btn secondary" id="pause">一時停止</button>
    </div>

    <h2>フレーム/チェーン</h2>
    <div class="row"><label>フレーム質量 m<sub>F</sub> [kg]</label><input id="mf" type="range" min="10" max="800" step="10" value="150"><span id="mfv">150</span></div>
    <div class="row"><label>チェーン長 L<sub>c</sub> [mm]</label><input id="Lc" type="range" min="50" max="2000" step="1" value="150"><span id="Lcv">150</span></div>

    <h2>アーム（落とし→ひざ→縦棒→棚＋返し）</h2>
    <div class="row"><label>落とし L<sub>drop</sub> [mm]</label><input id="ldrop" type="range" min="40" max="800" step="5" value="220"><span id="ldropv">220</span></div>
    <div class="row"><label>ひざ 外 L<sub>knee</sub> [mm]</label><input id="lknee" type="range" min="40" max="600" step="5" value="140"><span id="lkneev">140</span></div>
    <div class="row"><label>ひざ 下 D<sub>knee</sub> [mm]</label><input id="dknee" type="range" min="40" max="600" step="5" value="160"><span id="dkneev">160</span></div>
    <div class="row"><label>縦棒 L<sub>vert</sub> [mm]</label><input id="lvert" type="range" min="200" max="3000" step="10" value="1200"><span id="lvertv">1200</span></div>
    <div class="row"><label>棚長 L<sub>s</sub> [mm]</label><input id="slen" type="range" min="40" max="800" step="5" value="160"><span id="slenv">160</span></div>
    <div class="row"><label>返し高さ H<sub>lip</sub> [mm]</label><input id="hlip" type="range" min="10" max="200" step="2" value="80"><span id="hlipv">80</span></div>

    <h2>CAB</h2>
    <div class="row"><label>質量 m [kg]</label><input id="mass" type="range" min="50" max="3000" step="10" value="400"><span id="massv">400</span></div>
    <div class="row"><label>幅 W [mm]</label><input id="W" type="range" min="400" max="4000" step="10" value="1800"><span id="Wv">1800</span></div>
    <div class="row"><label>高さ H [mm]</label><input id="H" type="range" min="400" max="4000" step="10" value="1200"><span id="Hv">1200</span></div>
    <div class="row"><label>初期 COM X [mm]</label><input id="cx0" type="range" min="-4000" max="4000" step="1" value="7"><span id="cx0v">7</span></div>
    <div class="row"><label>摩擦係数 μ</label><input id="mu" type="range" min="0" max="1" step="0.01" value="0.30"><span id="muv">0.30</span></div>
    <div class="row"><label>回転減衰 cφ [N·m·s/rad]</label><input id="cdphi" type="range" min="0" max="200" step="1" value="10"><span id="cdphiv">10</span></div>

    <div class="legend" style="margin-top:8px">
      操作：<span class="kbd">←</span><span class="kbd">→</span> = 台車加減速（|v|≤0.3m/s）、<span class="kbd">Space</span> = ブレーキ、<span class="kbd">P</span> = 一時停止、<span class="kbd">R</span> = リセット
    </div>
    <pre id="readout" class="legend" style="background:#0e152e;padding:8px;border-radius:10px;white-space:pre-wrap"></pre>
  </div>

  <div class="card" style="position:relative;overflow:hidden"><canvas id="cv"></canvas></div>
</div>

<script>
(function(){
  // ===== Canvas =====
  const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
  const DPR=Math.max(1,window.devicePixelRatio||1);
  function resize(){const r=cv.getBoundingClientRect();const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;}}
  window.addEventListener('resize',resize); resize();
  function PPM(){const W=cv.width,H=cv.height;return Math.max(Math.min(W/6000,H/4200),0.08);}

  // ===== Bind UI =====
  function bind(id, lab, setter, fmt){const s=document.getElementById(id),l=document.getElementById(lab);const apply=()=>{const v=parseFloat(s.value);setter(v);l.textContent=fmt?fmt(v):String(v)};s.addEventListener('input',apply);apply();}
  let a_cmd=3000, vmax=300, ccart=0.26;
  let mF=150, Lc=150;
  let frameSpan=2400, frameH=120;
  let anchor_local={x:0, y:80};
  let rootL_local={x:-700, y:-100}, rootR_local={x:700, y:-100};
  let L_drop=220, L_knee=140, D_knee=160, L_vert=1200, Ls=160, H_lip=80;
  let m=400, Wmm=1800, Hmm=1200, mu=0.30, cdphi=10, cx0=7;
  bind('acmd','acmdv',v=>a_cmd=v,v=>v.toFixed(0));
  bind('vmax','vmaxv',v=>vmax=v,v=>v.toFixed(0));
  bind('cd','cdv',v=>ccart=v,v=>v.toFixed(2));
  bind('mf','mfv',v=>mF=v,v=>v.toFixed(0));
  bind('Lc','Lcv',v=>Lc=v,v=>v.toFixed(0));
  bind('ldrop','ldropv',v=>L_drop=v,v=>v.toFixed(0));
  bind('lknee','lkneev',v=>L_knee=v,v=>v.toFixed(0));
  bind('dknee','dkneev',v=>D_knee=v,v=>v.toFixed(0));
  bind('lvert','lvertv',v=>L_vert=v,v=>v.toFixed(0));
  bind('slen','slenv',v=>Ls=v,v=>v.toFixed(0));
  bind('hlip','hlipv',v=>H_lip=v,v=>v.toFixed(0));
  bind('mass','massv',v=>m=v,v=>v.toFixed(0));
  bind('W','Wv',v=>Wmm=v,v=>v.toFixed(0));
  bind('H','Hv',v=>Hmm=v,v=>v.toFixed(0));
  bind('cx0','cx0v',v=>cx0=v,v=>v.toFixed(0));
  bind('mu','muv',v=>mu=v,v=>v.toFixed(2));
  bind('cdphi','cdphiv',v=>cdphi=v,v=>v.toFixed(0));

  // ===== State =====
  let t=0, dt=1/600;
  // hoist
  let xt=0, vt=0;
  // frame (rigid)
  let xF=0, yF=-100, vFx=0, vFy=0, psi=0, wF=0;
  // arms (相対角は簡略、自由回転＆外90°ストップは省略可：拘束の本質に影響なし)
  // cab
  let cx=cx0, cy=-1800, cvx=0, cvy=0, phi=0, omega=0;

  // ===== Math utils =====
  const gmm=-9810, g=9.81;
  const eps=1e-9;
  function rot(a,v){const c=Math.cos(a),s=Math.sin(a);return {x:c*v.x - s*v.y, y:s*v.x + c*v.y};}
  function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
  function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
  function mul(v,k){return {x:v.x*k,y:v.y*k};}
  function len(v){return Math.hypot(v.x,v.y);}
  function norm(v){const L=len(v)||1;return {x:v.x/L,y:v.y/L};}
  function cross(a,b){return a.x*b.y - a.y*b.x;}
  function posF(local){return add({x:xF,y:yF}, rot(psi, local));}
  function velAt(local){const r=rot(psi,local); return {x:vFx - wF*r.y, y:vFy + wF*r.x};}
  function I_frame(){const W=frameSpan/1000,H=frameH/1000; return mF*(W*W+H*H)/12;}
  function I_cab(){const W=Wmm/1000,H=Hmm/1000; return m*(W*W+H*H)/12;}

  // ===== Chain constraint (rigid length) =====
  // 位置レベル：|A-H| = Lc を厳密化（1stepあたり数回反復）  ※フレームのみ修正、ホイストは運動学的
  function solveChainPosition(iter=3){
    for(let k=0;k<iter;k++){
      const H={x:xt,y:0}, A=posF(anchor_local);
      let r=sub(A,H); let L=len(r); if(L<eps) return;
      const n=mul(r,1/L); const C=L - Lc;           // 伸び(+)だけでなく常にゼロ化＝剛体長
      if(Math.abs(C)<1e-6) return;
      const rA=rot(psi,anchor_local);               // COM→アンカー
      const s = cross(rA, n);                       // 回転寄与
      const w = 1/mF, wrot = 1/Math.max(1e-9,I_frame());
      const denom = w + s*s*wrot;
      const dl = C/denom;                           // 位置レベルのラグランジュ増分
      // フレームの並進・回転を同時に補正（mm, rad）
      xF -= w    * n.x * dl;  yF -= w    * n.y * dl;
      psi-= wrot * s   * dl;
    }
  }

  // 速度レベル：チェーン方向の相対速度をゼロ化（張力のみ）
  function solveChainVelocity(){
    const H={x:xt,y:0}, vH={x:vt,y:0};
    const A=posF(anchor_local), vA=velAt(anchor_local);
    const r=sub(A,H); const L=len(r); if(L<eps) return;
    const n=mul(r,1/L);
    const vrel = ((vA.x - vH.x)*n.x + (vA.y - vH.y)*n.y)/1000; // m/s
    // 効質量（並進＋回転）
    const rAm=rot(psi,anchor_local); const rAm_m={x:rAm.x/1000,y:rAm.y/1000};
    const K = 1/mF + ( (rAm_m.x*n.y - rAm_m.y*n.x)**2 )/I_frame();
    let J = - vrel / K;                 // N·s（張力）
    if(J<0) J=0;                        // 張力のみ
    // フレームの速度を更新（ホイストは運動学的で変化なし）
    vFx += (-n.x*1000*J)/mF; vFy += (-n.y*1000*J)/mF;
    wF  += ( (rAm_m.x*(-J*n.y) - rAm_m.y*(-J*n.x)) )/I_frame();
  }

  // ===== Step =====
  const btnReset=document.getElementById('reset'), btnPause=document.getElementById('pause'); let paused=false;
  btnReset.onclick=()=>reset();
  btnPause.onclick=()=>{paused=!paused;btnPause.textContent=paused?'再開':'一時停止';};
  let keyL=false,keyR=false,brake=false;
  addEventListener('keydown',e=>{if(e.code==='ArrowLeft')keyL=true;if(e.code==='ArrowRight')keyR=true;if(e.code==='Space')brake=true;if(e.key==='r'||e.key==='R')reset();if(e.key==='p'||e.key==='P'){paused=!paused;btnPause.textContent=paused?'再開':'一時停止';}});
  addEventListener('keyup',e=>{if(e.code==='ArrowLeft')keyL=false;if(e.code==='ArrowRight')keyR=false;if(e.code==='Space')brake=false;});

  function reset(){
    t=0; xt=0; vt=0; xF=0; yF=-100; vFx=0; vFy=0; psi=0; wF=0;
    cx=cx0; cy=-1800; cvx=0; cvy=0; phi=0; omega=0;
    // 初回から張り長一致
    solveChainPosition(6);
    paused=false; btnPause.textContent='一時停止';
  }

  function step(){
    // 1) Hoist（入力）—運動学的
    let u=0; if(keyL)u-=a_cmd; if(keyR)u+=a_cmd; if(brake)u+=-3*vt;
    vt += (u - ccart*vt)*dt; if(vt>vmax)vt=vmax; if(vt<-vmax)vt=-vmax; xt += vt*dt;

    // 2) 重力（フレーム粘性は完全無視）
    vFy += (gmm/1000)*dt;

    // 3) チェーン拘束：まず位置で剛体長を満たす
    solveChainPosition(3);

    // 4) 速度レベルでもチェーン方向相対速度をゼロ化（慣性遅れを保ちつつ伸びを抑止）
    solveChainVelocity();

    // 5) フレーム積分
    xF += vFx*dt; yF += vFy*dt; psi += wF*dt;

    // 6) 接触（棚＋返し）：最小構成（左棚のみでもOK）。必要に応じて右側も追加可能。
    // ここでは簡略（棚は水平、返しは外向き垂直）※本質は慣性遅れ＆チェーン剛性なので省略可
    const shelfY = yF -  (D_knee + L_drop + L_vert); // 左棚の高さ近似
    const shelfX0 = xF - 600, shelfX1 = xF + 600;     // 幅近似
    // CAB上面中心の世界座標
    const cph=Math.cos(phi), sph=Math.sin(phi);
    const yG = Hmm/2 - 80; // 溝深さ近似
    const xL_loc=-Wmm/2 + 60, xR_loc=Wmm/2 - 60;
    const pCL={x:cx + cph*xL_loc - sph*yG, y:cy + sph*xL_loc + cph*yG};
    const pCR={x:cx + cph*xR_loc - sph*yG, y:cy + sph*xR_loc + cph*yG};
    // 棚面（上向き法線）
    const n={x:0,y:1}, tdir={x:1,y:0};
    function contact(P){
      if(P.x<shelfX0 || P.x>shelfX1) return;
      const pen = (shelfY - P.y); // Pが棚より下→負、上→正
      const vP={x:cvx - omega*(P.y-cy), y:cvy + omega*(P.x-cx)};
      if(pen>0 && vP.y<0){ // めり込み & 近づき
        // 法線
        const Icab=I_cab();
        const r={x:(P.x-cx)/1000, y:(P.y-cy)/1000};
        const K = 1/m + ((r.x*n.y - r.y*n.x)**2)/Icab;
        const vrelN = (vP.x*n.x + vP.y*n.y)/1000;
        const Jn = Math.max(0, -vrelN/K);
        cvx += (1000*Jn*n.x)/m; cvy += (1000*Jn*n.y)/m; omega += ( (r.x*Jn*n.y - r.y*Jn*n.x) )/Icab;
        // 摩擦
        const vrelT = (vP.x*tdir.x + vP.y*tdir.y)/1000;
        const Kt=1/m + ((r.x*tdir.y - r.y*tdir.x)**2)/Icab;
        const Jt_unc = - vrelT/Kt; const Jt = Math.max(-mu*Jn, Math.min(mu*Jn, Jt_unc));
        cvx += (1000*Jt*tdir.x)/m; cvy += (1000*Jt*tdir.y)/m; omega += ( (r.x*Jt*tdir.y - r.y*Jt*tdir.x))/Icab;
      }
    }
    contact(pCL); contact(pCR);

    // 7) CAB自由落下
    cvy += gmm*dt/1000; cx += cvx*dt; cy += cvy*dt; const Icab=I_cab(); omega += (-cdphi*omega/Icab)*dt; phi += omega*dt;
  }

  // ===== Draw =====
  const readout=document.getElementById('readout');
  function draw(){
    const s=PPM(); resize(); const W=cv.width,H=cv.height; const ox=W*0.5, oy=H*0.15; const sx=x=>ox+x*s, sy=y=>oy-y*s;
    ctx.clearRect(0,0,W,H);
    // grid
    ctx.save(); ctx.strokeStyle='#1b2445'; ctx.lineWidth=1; for(let x=-8000;x<=8000;x+=200){ctx.beginPath();ctx.moveTo(sx(x),0);ctx.lineTo(sx(x),H);ctx.stroke();}
    for(let y=-4000;y<=4000;y+=200){ctx.beginPath();ctx.moveTo(0,sy(y));ctx.lineTo(W,sy(y));ctx.stroke();} ctx.restore();
    // hoist & chain
    ctx.fillStyle='#26d07c'; ctx.fillRect(sx(xt)-110, sy(200)-60, 220, 120);
    ctx.strokeStyle='#26d07c'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(0)); ctx.lineTo(sx(xt),sy(200)); ctx.stroke();
    const anchor=posF(anchor_local); ctx.strokeStyle='#7bd6a8'; ctx.beginPath(); ctx.moveTo(sx(xt),sy(0)); ctx.lineTo(sx(anchor.x), sy(anchor.y)); ctx.stroke();
    // frame beam
    ctx.save(); ctx.translate(sx(xF), sy(yF)); ctx.rotate(-psi); ctx.fillStyle='#ff7070'; ctx.fillRect(-frameSpan*s/2, -frameH*s/2, frameSpan*s, frameH*s); ctx.restore();
    // very simple arm (概形)
    ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6;
    function drawArm(rootX){
      const base={x:rootX,y:yF}, d=rot(psi,{x:1,y:0}), n={x:-d.y,y:d.x};
      const P0=add({x:rootX,y:yF}, mul(d, 0)); const P1=add(P0, mul(n, 0)); // ルート
      const P2=add(P1, mul(d, L_drop)); const P3=add(P2, add(mul(n, (rootX<xF)?L_knee:-L_knee), mul(d, D_knee)));
      const P4=add(P3, mul(d, L_vert)); const P5=add(P4, mul({x:-n.x,y:-n.y}, Ls)); const P6=add(P5, mul({x:d.x,y:d.y}, -H_lip));
      ctx.beginPath(); ctx.moveTo(sx(P1.x),sy(P1.y)); [P2,P3,P4,P5,P6].forEach(p=>{ctx.lineTo(sx(p.x),sy(p.y));}); ctx.stroke();
      // shelf highlight
      ctx.strokeStyle='#ff9a9a'; ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(sx(P4.x),sy(P4.y)); ctx.lineTo(sx(P5.x),sy(P5.y)); ctx.stroke();
      ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6;
    }
    drawArm(xF-700); drawArm(xF+700);

    // CAB
    ctx.save(); ctx.translate(sx(cx), sy(cy)); ctx.rotate(-phi);
    ctx.fillStyle='rgba(127,182,255,0.9)'; ctx.fillRect(-Wmm*s/2, +Hmm*s/2 - Hmm*s, Wmm*s, Hmm*s); ctx.restore();

    readout.textContent =
      `t=${t.toFixed(2)} s\n`+
      `Hoist x=${xt.toFixed(1)} mm, v=${vt.toFixed(1)} mm/s (≤${vmax.toFixed(0)})\n`+
      `Frame c=(${xF.toFixed(1)}, ${yF.toFixed(1)}) ψ=${(psi*180/Math.PI).toFixed(2)}°\n`+
      `CAB c=(${cx.toFixed(1)}, ${cy.toFixed(1)}) φ=${(phi*180/Math.PI).toFixed(2)}°`;
  }

  // loop
  let last=performance.now(), acc=0;
  function loop(now){
    const el=(now-last)/1000; last=now;
    if(!paused){ acc+=Math.min(el,0.12); while(acc>=dt){ step(); t+=dt; acc-=dt; } }
    draw(); requestAnimationFrame(loop);
  }
  reset(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
