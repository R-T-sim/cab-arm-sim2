<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CAB 2D v5（張力のみの剛体チェーン / 受面で持上げ / 慣性遅れ / アーム自由）</title>
<style>
:root{--bg:#0b1020;--fg:#e8eef9;--muted:#9fb3d9;--card:#121a33;--good:#26d07c;--arm:#ff5a5a;--cab:#7fb6ff}
html,body{height:100%}body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
.card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.panel{padding:14px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px}h2{font-size:13px;margin:8px 0 2px;color:var(--muted);font-weight:600}
.row{display:flex;align-items:center;gap:10px}.row label{min-width:170px;font-size:12px;color:var(--muted)}
input[type=range]{width:100%}.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:12px;padding:9px 12px;cursor:pointer;font-weight:600}
.btn.secondary{background:#19254a;color:var(--fg);border:1px solid #2a3a6a}
.kbd{display:inline-block;padding:2px 8px;border-radius:8px;background:#10172a;border:1px solid #1d2744;font-size:12px;color:var(--muted)}
.legend{font-size:12px;color:var(--muted)}canvas{width:100%;height:100%;display:block}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>ホイスト（緑：操作）＋ 吊具フレーム＆アーム（赤）＋ CAB（青）</h1>
      <div class="legend">
        原点=フック(0,0)、X右＋/Y上＋、単位=mm。重力は下向き 9.8 m/s²。台車は |v| ≤ 0.3 m/s。<br>
        v5：<b>チェーンは剛体長・張力のみ</b>、<b>受面は一方向接触＋摩擦</b>、<b>アーム根元は開き方向フリー</b>。
      </div>
    </div>

    <h2>ホイスト</h2>
    <div class="row"><label>指令加速度 a<sub>cmd</sub> [mm/s²]</label><input id="acmd" type="range" min="100" max="6000" step="50" value="3000"><span id="acmdv">3000</span></div>
    <div class="row"><label>速度上限 |vᵗ|max [mm/s]</label><input id="vmax" type="range" min="50" max="600" step="10" value="300"><span id="vmaxv">300</span></div>
    <div class="row"><label>台車粘性 cᵗ [1/s]</label><input id="cd" type="range" min="0" max="2" step="0.02" value="0.26"><span id="cdv">0.26</span></div>

    <div class="row" style="gap:12px;margin-top:6px;flex-wrap:wrap">
      <button class="btn" id="reset">リセット</button>
      <button class="btn secondary" id="pause">一時停止</button>
    </div>

    <h2>フレーム/チェーン</h2>
    <div class="row"><label>フレーム質量 m<sub>F</sub> [kg]</label><input id="mf" type="range" min="10" max="800" step="10" value="150"><span id="mfv">150</span></div>
    <div class="row"><label>チェーン長 L<sub>c</sub> [mm]</label><input id="Lc" type="range" min="50" max="2000" step="1" value="150"><span id="Lcv">150</span></div>

    <h2>アーム（落とし→ひざ→縦棒→棚＋返し）</h2>
    <div class="row"><label>落とし L<sub>drop</sub> [mm]</label><input id="ldrop" type="range" min="40" max="800" step="5" value="220"><span id="ldropv">220</span></div>
    <div class="row"><label>ひざ 外 L<sub>knee</sub> [mm]</label><input id="lknee" type="range" min="40" max="600" step="5" value="140"><span id="lkneev">140</span></div>
    <div class="row"><label>ひざ 下 D<sub>knee</sub> [mm]</label><input id="dknee" type="range" min="40" max="600" step="5" value="160"><span id="dkneev">160</span></div>
    <div class="row"><label>縦棒 L<sub>vert</sub> [mm]</label><input id="lvert" type="range" min="200" max="3000" step="10" value="1200"><span id="lvertv">1200</span></div>
    <div class="row"><label>棚長 L<sub>s</sub> [mm]</label><input id="slen" type="range" min="40" max="800" step="5" value="160"><span id="slenv">160</span></div>
    <div class="row"><label>返し高さ H<sub>lip</sub> [mm]</label><input id="hlip" type="range" min="10" max="200" step="2" value="80"><span id="hlipv">80</span></div>

    <h2>CAB</h2>
    <div class="row"><label>質量 m [kg]</label><input id="mass" type="range" min="50" max="3000" step="10" value="400"><span id="massv">400</span></div>
    <div class="row"><label>幅 W [mm]</label><input id="W" type="range" min="400" max="4000" step="10" value="1800"><span id="Wv">1800</span></div>
    <div class="row"><label>高さ H [mm]</label><input id="H" type="range" min="400" max="4000" step="10" value="1200"><span id="Hv">1200</span></div>
    <div class="row"><label>初期 COM X [mm]</label><input id="cx0" type="range" min="-4000" max="4000" step="1" value="7"><span id="cx0v">7</span></div>
    <div class="row"><label>摩擦係数 μ</label><input id="mu" type="range" min="0" max="1" step="0.01" value="0.30"><span id="muv">0.30</span></div>
    <div class="row"><label>回転減衰 cφ [N·m·s/rad]</label><input id="cdphi" type="range" min="0" max="200" step="1" value="10"><span id="cdphiv">10</span></div>

    <div class="legend" style="margin-top:8px">
      操作：<span class="kbd">←</span><span class="kbd">→</span> = 台車加減速（|v|≤0.3m/s）、<span class="kbd">Space</span> = ブレーキ、<span class="kbd">P</span> = 一時停止、<span class="kbd">R</span> = リセット
    </div>
    <pre id="readout" class="legend" style="background:#0e152e;padding:8px;border-radius:10px;white-space:pre-wrap"></pre>
  </div>

  <div class="card" style="position:relative;overflow:hidden"><canvas id="cv"></canvas></div>
</div>

<script>
(function(){
  // ===== Canvas =====
  const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
  const DPR=Math.max(1,window.devicePixelRatio||1);
  function resize(){const r=cv.getBoundingClientRect();const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;}}
  window.addEventListener('resize',resize); resize();
  function PPM(){const W=cv.width,H=cv.height;return Math.max(Math.min(W/6000,H/4200),0.08);}

  // ===== Bind UI =====
  function bind(id, lab, setter, fmt){const s=document.getElementById(id),l=document.getElementById(lab);const apply=()=>{const v=parseFloat(s.value);setter(v);l.textContent=fmt?fmt(v):String(v)};s.addEventListener('input',apply);apply();}
  let a_cmd=3000, vmax=300, ccart=0.26;
  let mF=150, Lc=150;
  let frameSpan=2400, frameH=120;
  let anchor_local={x:0, y:80};
  let rootL_local={x:-700, y:-100}, rootR_local={x:700, y:-100};
  let L_drop=220, L_knee=140, D_knee=160, L_vert=1200, Ls=160, H_lip=80;
  let m=400, Wmm=1800, Hmm=1200, mu=0.30, cdphi=10, cx0=7;
  bind('acmd','acmdv',v=>a_cmd=v,v=>v.toFixed(0));
  bind('vmax','vmaxv',v=>vmax=v,v=>v.toFixed(0));
  bind('cd','cdv',v=>ccart=v,v=>v.toFixed(2));
  bind('mf','mfv',v=>mF=v,v=>v.toFixed(0));
  bind('Lc','Lcv',v=>Lc=v,v=>v.toFixed(0));
  bind('ldrop','ldropv',v=>L_drop=v,v=>v.toFixed(0));
  bind('lknee','lkneev',v=>L_knee=v,v=>v.toFixed(0));
  bind('dknee','dkneev',v=>D_knee=v,v=>v.toFixed(0));
  bind('lvert','lvertv',v=>L_vert=v,v=>v.toFixed(0));
  bind('slen','slenv',v=>Ls=v,v=>v.toFixed(0));
  bind('hlip','hlipv',v=>H_lip=v,v=>v.toFixed(0));
  bind('mass','massv',v=>m=v,v=>v.toFixed(0));
  bind('W','Wv',v=>Wmm=v,v=>v.toFixed(0));
  bind('H','Hv',v=>Hmm=v,v=>v.toFixed(0));
  bind('cx0','cx0v',v=>cx0=v,v=>v.toFixed(0));
  bind('mu','muv',v=>mu=v,v=>v.toFixed(2));
  bind('cdphi','cdphiv',v=>cdphi=v,v=>v.toFixed(0));

  // ===== State =====
  let t=0, dt=1/600;
  const SUB_STEPS = 8;   // サブステップ
  const EPS = 1e-9;

  // hoist
  let xt=0, vt=0;
  // frame
  let xF=0, yF=-100, vFx=0, vFy=0, psi=0, wF=0;
  // arms（相対角：開き方向フリー）
  let thL_rel=-Math.PI/2, wL_rel=0, thR_rel=-Math.PI/2, wR_rel=0;
  const L_st=[-Math.PI,-Math.PI/2], R_st=[-Math.PI/2,0]; // 左:[-180,-90] 右:[-90,0]
  const mArm=30, cArm=10;
  // cab
  let cx=cx0, cy=-1800, cvx=0, cvy=0, phi=0, omega=0;

  // ===== Math utils =====
  const gmm=-9810, g=9.81;
  function rot(a,v){const c=Math.cos(a),s=Math.sin(a);return {x:c*v.x - s*v.y, y:s*v.x + c*v.y};}
  function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
  function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
  function mul(v,k){return {x:v.x*k,y:v.y*k};}
  function len(v){return Math.hypot(v.x,v.y);}
  function norm(v){const L=len(v)||1;return {x:v.x/L,y:v.y/L};}
  function dot(a,b){return a.x*b.x+a.y*b.y;}
  function posF(local){return add({x:xF,y:yF}, rot(psi, local));}
  function velAt(local){const r=rot(psi,local); return {x:vFx - wF*r.y, y:vFy + wF*r.x};}
  function I_frame(){const W=frameSpan/1000,H=frameH/1000; return mF*(W*W+H*H)/12;}
  function I_cab(){const W=Wmm/1000,H=Hmm/1000; return m*(W*W+H*H)/12;}

  // ===== Arm geometry（棚＋返しの平面と向き）=====
  function armGeom(side, rootW, vRoot, thAbs, wAbs){
    const d={x:Math.cos(thAbs),y:Math.sin(thAbs)};          // アーム軸（下向きが初期）
    const n={x:-d.x,y:-d.y};                                // 棚の法線（上向き）
    const t={x:-n.y,y:n.x};                                 // 法線に直交
    const out = (side==='L')? t : {x:-t.x,y:-t.y};          // 外向き
    const inw = {x:-out.x,y:-out.y};

    const P0=rootW;
    const P1=add(P0, mul(d, L_drop));
    const P2=add(P1, add(mul(out, L_knee), mul(d, D_knee)));
    const P3=add(P2, mul(d, L_vert));
    const S0=P3;                       // 棚外端
    const S1=add(S0, mul(inw, Ls));    // 棚内端
    const LIP=add(S1, mul(n, H_lip));  // 返し先端

    function vOf(p){return {x:vRoot.x - wAbs*(p.y-rootW.y), y:vRoot.y + wAbs*(p.x-rootW.x)};}
    return {
      poly:[P0,P1,P2,P3,S0,S1,LIP],
      shelfOrigin:S0, shelfN:n, shelfT:inw, vShelf:vOf(S0),
      lipOrigin:S1,   lipN:out,          vLip:vOf(S1)
    };
  }

  // ===== Contact solver（片側＋摩擦＋微小Baumgarte）=====
  function contactPlane(S, VS, n, tdir, Pc, Vc, rCm, pivotW, applyFrame){
    // d>0: 上（離間） / d<0: めり込み
    const d = dot(sub(Pc,S), n);
    const vrelN = ( (Vc.x - VS.x)*n.x + (Vc.y - VS.y)*n.y )/1000;
    const beta = 40;                          // 位置安定化 [1/s]
    const vBias = (d<0 ? beta*( -d/1000 ) : 0); // penetration を押し戻す

    // 法線インパルス（押し方向のみ）
    const Icab=I_cab();
    const K = 1/m + ( ((rCm.x*n.y - rCm.y*n.x)**2) / Icab );
    let Jn = -(vrelN - vBias) / K;            // vrelN を 0 に、+vBias で持上げ
    if (Jn < 0) Jn = 0;

    // CAB側更新
    const JnV={x:Jn*n.x,y:Jn*n.y};
    cvx += (1000*JnV.x)/m; cvy += (1000*JnV.y)/m;
    omega += ( (rCm.x*JnV.y - rCm.y*JnV.x) )/Icab;

    // フレーム側（必要なら）
    if(applyFrame){
      vFx += (-1000*JnV.x)/mF; vFy += (-1000*JnV.y)/mF;
      const rPFm={x:(pivotW.x - xF)/1000, y:(pivotW.y - yF)/1000};
      wF  += ( (rPFm.x*(-JnV.y) - rPFm.y*(-JnV.x)) )/I_frame();
    }

    // 摩擦（クーロン）
    const vrelT = ( (Vc.x - VS.x)*tdir.x + (Vc.y - VS.y)*tdir.y )/1000;
    const Kt = 1/m + ( ((rCm.x*tdir.y - rCm.y*tdir.x)**2) / Icab );
    let Jt_unc = - vrelT / Kt;
    const lim = mu * Jn;
    const Jt = Math.max(-lim, Math.min(lim, Jt_unc));
    const JtV={x:Jt*tdir.x,y:Jt*tdir.y};
    cvx += (1000*JtV.x)/m; cvy += (1000*JtV.y)/m;
    omega += ( (rCm.x*JtV.y - rCm.y*JtV.x) )/Icab;

    if(applyFrame){
      vFx += (-1000*JtV.x)/mF; vFy += (-1000*JtV.y)/mF;
      const rPFm={x:(pivotW.x - xF)/1000, y:(pivotW.y - yF)/1000};
      wF  += ( (rPFm.x*(-JtV.y) - rPFm.y*(-JtV.x)) )/I_frame();
    }
  }

  // ===== Chain constraint（剛体長・張力のみ）=====
  // 位置レベル：L > Lc のときだけ補正（Slack なら何もしない）
  function solveChainPosition(iter=3){
    for(let k=0;k<iter;k++){
      const H={x:xt,y:0}, A=posF(anchor_local);
      const r=sub(A,H); const L=len(r); if(L<EPS) return;
      if(L <= Lc) return; // 張ってないときは補正しない
      const n=mul(r,1/L);
      const C=L - Lc;
      const rA=rot(psi,anchor_local);
      const s = rA.x*n.y - rA.y*n.x;
      const w = 1/mF, wr = 1/Math.max(1e-9, I_frame());
      const denom = w + s*s*wr;
      const dl = C/denom;
      xF  -= w  * n.x * dl;
      yF  -= w  * n.y * dl;
      psi -= wr * s   * dl;
    }
  }
  // 速度レベル：離れていく（vrelN>0）ときだけ張力を入れる
  function solveChainVelocity(){
    const H={x:xt,y:0}, vH={x:vt,y:0};
    const A=posF(anchor_local), vA=velAt(anchor_local);
    const r=sub(A,H); const L=len(r); if(L<EPS) return;
    const n=mul(r,1/L);
    const rAm=rot(psi,anchor_local); const rAm_m={x:rAm.x/1000,y:rAm.y/1000};
    const vrelN = ((vA.x - vH.x)*n.x + (vA.y - vH.y)*n.y)/1000;  // m/s
    const K = 1/mF + ((rAm_m.x*n.y - rAm_m.y*n.x)**2)/I_frame();
    let J = (vrelN>0) ? ( vrelN / K ) : 0;                        // 伸び方向のみ
    vFx += (-n.x*1000*J)/mF; vFy += (-n.y*1000*J)/mF;
    wF  += ( (rAm_m.x*(-J*n.y) - rAm_m.y*(-J*n.x)) )/I_frame();
  }

  // ===== Step / Reset =====
  const btnReset=document.getElementById('reset'), btnPause=document.getElementById('pause'); let paused=false;
  btnReset.onclick=()=>reset();
  btnPause.onclick=()=>{paused=!paused;btnPause.textContent=paused?'再開':'一時停止';};
  let keyL=false,keyR=false,brake=false;
  addEventListener('keydown',e=>{if(e.code==='ArrowLeft')keyL=true;if(e.code==='ArrowRight')keyR=true;if(e.code==='Space')brake=true;if(e.key==='r'||e.key==='R')reset();if(e.key==='p'||e.key==='P'){paused=!paused;btnPause.textContent=paused?'再開':'一時停止';}});
  addEventListener('keyup',e=>{if(e.code==='ArrowLeft')keyL=false;if(e.code==='ArrowRight')keyR=false;if(e.code==='Space')brake=false;});

  function reset(){
    t=0;
    // Hoist
    xt=0; vt=0;
    // Frame：ψ=0 かつ |A-H|=Lc を満たす
    xF = xt - anchor_local.x;
    yF = -anchor_local.y - Lc;
    vFx=0; vFy=0; psi=0; wF=0;

    // Arms：鉛直下、受動
    thL_rel=-Math.PI/2; wL_rel=0; thR_rel=-Math.PI/2; wR_rel=0;

    // CAB：左棚高さに静置
    const rootLW = posF(rootL_local);
    const Lsum = L_drop + D_knee + L_vert;
    const S0L  = add(rootLW, {x:0, y:-Lsum});
    const yG   = Hmm/2 - 80;
    cx=cx0; cy=S0L.y - yG; cvx=0; cvy=0; phi=0; omega=0;

    paused=false; btnPause.textContent='一時停止';
  }

  function step(){
    const h = dt / SUB_STEPS;
    for(let s=0;s<SUB_STEPS;s++){
      // 1) Hoist
      let u=0; if(keyL)u-=a_cmd; if(keyR)u+=a_cmd; if(brake)u+=-3*vt;
      vt += (u - ccart*vt)*h;
      if(vt>vmax)vt=vmax; if(vt<-vmax)vt=-vmax;
      xt += vt*h;

      // 2) 重力（フレーム粘性は無視）
      vFy += (gmm/1000)*h;

      // 3) チェーン拘束：位置→速度（張力のみ）
      solveChainPosition(3);
      solveChainVelocity();

      // 4) フレーム積分
      xF += vFx*h; yF += vFy*h; psi += wF*h;

      // 5) アーム根元（受動回転・外90°ストップ）
      const Lm=(L_drop + D_knee + L_vert)/1000, Rm=(L_drop + D_knee + L_vert)/1000;
      const IarmL=Math.max(1e-6,mArm*Lm*Lm/3), IarmR=Math.max(1e-6,mArm*Rm*Rm/3);
      const thL=psi+thL_rel, thR=psi+thR_rel;
      const tauLg = - mArm*g*(Lm/2)*Math.cos(thL), tauRg = - mArm*g*(Rm/2)*Math.cos(thR);
      wL_rel += ((tauLg - cArm*wL_rel)/IarmL)*h; wR_rel += ((tauRg - cArm*wR_rel)/IarmR)*h;
      thL_rel += wL_rel*h; thR_rel += wR_rel*h;
      if(thL_rel > L_st[1]){thL_rel=L_st[1]; if(wL_rel>0) wL_rel=0;}
      if(thL_rel < L_st[0]){thL_rel=L_st[0]; if(wL_rel<0) wL_rel=0;}
      if(thR_rel > R_st[1]){thR_rel=R_st[1]; if(wR_rel>0) wR_rel=0;}
      if(thR_rel < R_st[0]){thR_rel=R_st[0]; if(wR_rel<0) wR_rel=0;}

      // 6) アーム幾何 → 受面／返し接触
      const rootLW=posF(rootL_local), vRootL=velAt(rootL_local);
      const rootRW=posF(rootR_local), vRootR=velAt(rootR_local);
      const gL=armGeom('L',rootLW,vRootL,psi+thL_rel,wF+wL_rel);
      const gR=armGeom('R',rootRW,vRootR,psi+thR_rel,wF+wR_rel);

      // CAB 溝の2点（左右）
      const cph=Math.cos(phi), sph=Math.sin(phi);
      const yG=Hmm/2 - 80, xL_loc=-Wmm/2 + 60, xR_loc=Wmm/2 - 60;
      const pCL={x:cx + cph*xL_loc - sph*yG, y:cy + sph*xL_loc + cph*yG};
      const pCR={x:cx + cph*xR_loc - sph*yG, y:cy + sph*xR_loc + cph*yG};
      const vCL={x:cvx - omega*(sph*xL_loc + cph*yG), y:cvy + omega*(cph*xL_loc - sph*yG)};
      const vCR={x:cvx - omega*(sph*xR_loc + cph*yG), y:cvy + omega*(cph*xR_loc - sph*yG)};
      const rCLm={x:(pCL.x-cx)/1000, y:(pCL.y-cy)/1000}, rCRm={x:(pCR.x-cx)/1000, y:(pCR.y-cy)/1000};

      // 棚面（上向き法線）＋返し（外向き法線）—> CABを確実に持上げ
      contactPlane(gL.shelfOrigin,gL.vShelf,gL.shelfN,gL.shelfT,pCL,vCL,rCLm,rootLW,true);
      contactPlane(gR.shelfOrigin,gR.vShelf,gR.shelfN,gR.shelfT,pCR,vCR,rCRm,rootRW,true);
      const tL={x:-gL.shelfN.y,y:gL.shelfN.x}, tR={x:-gR.shelfN.y,y:gR.shelfN.x};
      contactPlane(gL.lipOrigin,gL.vLip,gL.lipN,tL,pCL,vCL,rCLm,rootLW,true);
      contactPlane(gR.lipOrigin,gR.vLip,gR.lipN,tR,pCR,vCR,rCRm,rootRW,true);

      // 7) CAB
      cvy += gmm*h/1000;
      cx += cvx*h; cy += cvy*h;
      const Icab=I_cab(); omega += (-cdphi*omega/Icab)*h; phi += omega*h;
    }
  }

  // ===== Draw =====
  const readout=document.getElementById('readout');
  function draw(){
    const s=PPM(); resize(); const W=cv.width,H=cv.height; const ox=W*0.5, oy=H*0.15; const sx=x=>ox+x*s, sy=y=>oy-y*s;
    ctx.clearRect(0,0,W,H);
    // grid
    ctx.save(); ctx.strokeStyle='#1b2445'; ctx.lineWidth=1;
    for(let x=-8000;x<=8000;x+=200){ctx.beginPath();ctx.moveTo(sx(x),0);ctx.lineTo(sx(x),H);ctx.stroke();}
    for(let y=-4000;y<=4000;y+=200){ctx.beginPath();ctx.moveTo(0,sy(y));ctx.lineTo(W,sy(y));ctx.stroke();}
    ctx.restore();

    // hoist & chain
    ctx.fillStyle='#26d07c'; ctx.fillRect(sx(xt)-110, sy(200)-60, 220, 120);
    ctx.strokeStyle='#26d07c'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(0)); ctx.lineTo(sx(xt),sy(200)); ctx.stroke();
    const anchor=posF(anchor_local); ctx.strokeStyle='#7bd6a8'; ctx.beginPath(); ctx.moveTo(sx(xt),sy(0)); ctx.lineTo(sx(anchor.x), sy(anchor.y)); ctx.stroke();

    // frame beam
    ctx.save(); ctx.translate(sx(xF), sy(yF)); ctx.rotate(-psi);
    ctx.fillStyle='#ff7070'; ctx.fillRect(-frameSpan*s/2, -frameH*s/2, frameSpan*s, frameH*s);
    ctx.restore();

    // arms
    function drawArm(poly){
      ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6; ctx.beginPath();
      ctx.moveTo(sx(poly[0].x),sy(poly[0].y));
      for(let i=1;i<poly.length;i++) ctx.lineTo(sx(poly[i].x),sy(poly[i].y));
      ctx.stroke();
      ctx.strokeStyle='#ff9a9a'; ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(sx(poly[4].x),sy(poly[4].y)); ctx.lineTo(sx(poly[5].x),sy(poly[5].y)); ctx.stroke();
    }
    // 再計算（描画用）
    const rootLW=posF(rootL_local), rootRW=posF(rootR_local);
    const gL=armGeom('L',rootLW,velAt(rootL_local),psi+thL_rel,wF+wL_rel);
    const gR=armGeom('R',rootRW,velAt(rootR_local),psi+thR_rel,wF+wR_rel);
    drawArm(gL.poly); drawArm(gR.poly);

    // CAB
    ctx.save(); ctx.translate(sx(cx), sy(cy)); ctx.rotate(-phi);
    ctx.fillStyle='rgba(127,182,255,0.9)'; ctx.fillRect(-Wmm*s/2, +Hmm*s/2 - Hmm*s, Wmm*s, Hmm*s);
    ctx.restore();

    readout.textContent =
      `t=${t.toFixed(2)} s  Hoist x=${xt.toFixed(1)} mm v=${vt.toFixed(1)} mm/s (≤${vmax.toFixed(0)})\n`+
      `Frame c=(${xF.toFixed(1)}, ${yF.toFixed(1)}) ψ=${(psi*180/Math.PI).toFixed(2)}°\n`+
      `ArmL θrel=${(thL_rel*180/Math.PI).toFixed(1)}°  ArmR θrel=${(thR_rel*180/Math.PI).toFixed(1)}°\n`+
      `CAB c=(${cx.toFixed(1)}, ${cy.toFixed(1)}) φ=${(phi*180/Math.PI).toFixed(2)}° μ=${mu.toFixed(2)}`;
  }

  // loop
  let last=performance.now(), acc=0;
  function loop(now){
    const el=(now-last)/1000; last=now;
    if(!paused){ acc+=Math.min(el,0.12); while(acc>=dt){ step(); t+=dt; acc-=dt; } }
    draw(); requestAnimationFrame(loop);
  }
  reset(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
